## app.R ##
suppressPackageStartupMessages({
  library(shiny)
  library(shinyjs)
  library(shinydashboard)
  library(DT)
  library(scienceverse)
  library(dplyr)
  library(tidyr)
  library(shiny.i18n)
})

source("R/constants.R")
source("R/funcs.R")
source("R/modules/section.R")
source("R/modules/cinfo.R")
source("i18n/trans.R")


## Interface Tab Items ----
source("tabs/study.R")
source("tabs/hyp.R")
source("tabs/ana.R")
source("tabs/dat.R")
source("tabs/met.R")
source("tabs/aut.R")
source("tabs/pre.R")
source("tabs/out.R")


## UI ----
ui <- dashboardPage(
  skin = "black",
  dashboardHeader(title = "Scienceverse"),
  dashboardSidebar(
    sidebarMenu(
      id = "tabs",
      menuItem("Study Info", tabName = "study_tab",
               icon = icon("yin-yang")),
      menuItem("Authors", tabName = "aut_tab",
               icon = icon("user-graduate")),
      menuItem("Hypotheses", tabName = "hyp_tab",
               icon = icon("lightbulb")),
      menuItem("Methods", tabName = "met_tab",
               icon = icon("cog")),
      menuItem("Data", tabName = "dat_tab",
               icon = icon("database")),
      menuItem("Analyses", tabName = "ana_tab",
               icon = icon("chart-bar")),
      menuItem("Summaries", tabName = "out_tab",
               icon = icon("file")),
      menuItem("Preregistration", tabName = "pre_tab",
               icon = icon("check-circle"))
    ),
    actionButton("demo", "Demo Study"),
    actionButton("reset_study", "Reset Study"),
    actionButton("return_study", "Quit & Return Study"),

    selectInput("lang", "Change language",
                choices = c(English = "en", Dutch = "nl"),
                selected = "en"),
    p("Most of the phrases have not been translated; this is just a proof of concept.", style="margin: 0 1em;")
  ),
  dashboardBody(
    shinyjs::useShinyjs(),
    tags$head(
      tags$link(rel = "stylesheet", type = "text/css", href = "custom.css"),
      tags$script(src = "custom.js")
    ),
    tabItems(
      study_tab,
      aut_tab,
      hyp_tab,
      met_tab,
      dat_tab,
      ana_tab,
      pre_tab,
      out_tab
    )
  )
)


## server ----
server <- function(input, output, session) {
  # reactiveVals ----
  debug_msg("----reactiveVals----")

  my_study <- reactiveVal( study(name = "", description = "") )

  aut_clear <- makeReactiveTrigger()
  hyp_clear <- makeReactiveTrigger()
  dat_clear <- makeReactiveTrigger()
  ana_clear <- makeReactiveTrigger()

  criteria <- reactiveVal(list())
  return_list <- reactiveVal(list())
  authors <- reactiveVal(list())
  loaded_data <- reactiveVal(data.frame())
  cb <- reactiveVal(codebook(data.frame(), "", return = "list"))
  level_list <- reactiveVal(list(A1 = "",
                                 A2 = ""))
  level_list_disp <- reactiveVal(list(A1 = "",
                                      A2 = ""))
  design <- reactiveVal(faux::check_design(plot = FALSE))
  sim <- reactiveValues(
    w_cells = c("y"),
    b_cells = c("y"),
    cell_names = c("y"),
    within = list(),
    between = list(),
    n = 100,
    mu = 0,
    sd = 1,
    r = 0,
    vardesc = list(description = list())
  )

  # custom info ----
  debug_msg("----custom info----")
  study_cinfo <- cinfoServer("study_info")
  hyp_cinfo <- cinfoServer("hyp_info")
  dat_cinfo <- cinfoServer("dat_info")
  met_cinfo <- cinfoServer("met_info")
  ana_cinfo <- cinfoServer("ana_info")
  aut_cinfo <- cinfoServer("aut_info")

  # met_sec <- sectionServer(
  #   "met_sec", "methods",
  #   c("met_id", "met_desc", "met_text", "met_type")
  # )

  # on startup ----
  shinyjs::hide("hyp_delete")
  shinyjs::hide("dat_delete")
  shinyjs::hide("aut_delete")
  shinyjs::hide("aut_reorder")
  shinyjs::hide("download_data")
  shinyjs::hide("download_cb")
  shinyjs::hide("ana_delete")
  shinyjs::hide("study_analyse")


  # functions ----
  section_delete <- function(section, idx) {
    s <- my_study()
    idx <- as.integer(idx)
    s[[section]][idx] <- NULL
    my_study(s)
  }

  # disable/enable buttons depending on presence of inputs
  buttonable <- function(button, ...) {
    blanks <- list(...) %>% trimws() == ""

    if (any(blanks)) {
      shinyjs::disable(button)
    } else {
      shinyjs::enable(button)
    }
  }

  ## translation ----
  debug_msg("----translation ----")

  ## . . i18n ----
  i18n <- reactive({
    selected <- input$lang
    if (length(selected) > 0 && selected %in% translator$get_languages()) {
      translator$set_translation_language(selected)
    }
    translator
  })

  # . . lang ----
  observeEvent(input$lang, {
    debug_msg("lang")

    # text changes (h3, h4, p)
    for (h in trans_text) {
      suppressWarnings(tt <- i18n()$t(h))

      js <- sprintf("$('*[en=\"%s\"]').text(\"%s\");",
                    gsub("'", "\\\\'", h), tt)
      shinyjs::runjs(js)
    }

    # input label changes
    for (func in names(trans_labels)) {
      for (nm in names(trans_labels[[func]])) {
        l <- trans_labels[[func]][[nm]]
        tl <- suppressWarnings(
          i18n()$t(l)
        )

        args <- list(
          session = session,
          inputId = nm,
          label = tl
        )
        do.call(func, args)
      }
    }
  }, ignoreInit = TRUE)


  # study ----

  observeEvent(c(input$study_name,
                 input$study_title,
                 input$study_desc,
                 input$study_keywords,
                 study_cinfo$disp()), {
    debug_msg("study_info")
    s <- my_study()
    s$name <- input$study_name
    ci <- study_cinfo$disp() %>% dfnv()
    kw <- strsplit(input$study_keywords, "\\s*;\\s*")[[1]] %>%
      trimws() %>% unique()
    s$info <- c(list(title = input$study_title,
                     description = input$study_desc,
                     keywords = kw),
                ci)

    my_study(s)
  })

  # . . return_study ----
  observeEvent(input$return_study, {
    debug_msg("return_study")

    stopApp(my_study())
  })

  # . . reset_study ----
  observeEvent(input$reset_study, {
    debug_msg("reset_study")

    # reset all IDs from trans_labels
    trans_labels %>%
      unname() %>%
      unlist() %>%
      names() %>%
      lapply(shinyjs::reset)

    # not sure why these aren't captured above
    c("ana_return_name", "ana_return_object") %>%
      lapply(shinyjs::reset)

    criteria(list())
    return_list(list())
    authors(list())
    loaded_data(data.frame())
    cb(codebook(data.frame(), "", return = "list"))

    study_cinfo$info(NULL)
    shinyjs::click("sim_clear")
    shinyjs::click("aut_clear")
    shinyjs::click("hyp_clear")
    shinyjs::click("met_clear")
    shinyjs::click("ana_clear")
    shinyjs::click("dat_clear")
    shinyjs::hide("study_analyse")

    s <- study(name = input$study_name,
               description = input$study_desc)
    my_study(s)
  })

  # . . study_analyse ----
  observeEvent(input$study_analyse, {
    debug_msg("study_analyse")
    s <- my_study()

    if (length(s$analyses) == 0) {
      i18n()$t("No analyses have been specified") %>%
        shinyjs::alert()
    } else {
      tryCatch(s <- study_analyse(s),
               error = function(e) {
                 shinyjs::alert(e$message)
               })
      #updateTabItems(session, "tabs", "ana_tab")
      shinyjs::runjs("openBox('ana_results-box');")
      my_study(s)
    }
  })


  # authors ----
  debug_msg("---authors---")

  # . . get_orcid ----
  observeEvent(input$get_orcid, {
    debug_msg("get_orcid")

    o <- tryCatch({
      get_orcid(input$surname, input$given)
    }, error = function(e) {
      return(NULL)
    })

    n <- length(o)
    if (n == 1) {
      updateTextInput(session, "orcid", value = o)
    } else {
      i18n()$t("%d ORCiDs found") %>%
        sprintf(n) %>%
        shinyjs::alert()
    }
  })

  # . . aut_add ----
  observe({
    buttonable("aut_add",
               input$surname,
               input$given)
  })

  observeEvent(input$aut_add, {
    debug_msg("aut_add")

    problems <- FALSE

    # check orcid
    if (input$orcid != "") {
      orcid <- check_orcid(input$orcid)
      if (isFALSE(orcid)) {
        problems <- TRUE
        updateTextInput(session, "orcid",
                        label = "ORCiD is not valid" %>% i18n()$t())
        shinyjs::addClass("orcid", "warning")
      }
    } else {
      orcid <- ""
    }

    # check names
    for (nm in c("surname", "given")) {
      if (trimws(input[[nm]]) == "") {
        problems <- TRUE
        label <- ifelse(nm == "given",
                        "Given name",
                        "Last name") %>%
          paste("is missing") %>% i18n()$t()
        updateTextInput(session, nm, label = label)
        shinyjs::addClass(nm, "warning")
      }
    }

    if (!problems) {
      # add author
      a <- list(surname = trimws(input$surname),
                given = trimws(input$given),
                orcid = orcid,
                roles = input$roles)
      a <- c(a, dfnv(aut_cinfo$disp()))
      aa <- authors()
      aa[[input$aut_n]] <- a
      authors(aa)

      shinyjs::click("aut_clear")
    }
  }, ignoreNULL = TRUE)

  # . . add_author ----
  observeEvent(authors(), {
    debug_msg("add_author")

    # update study$authors whenever authors() changes
    s <- my_study()
    s$authors <- list()
    for (a in authors()) {
      s <- tryCatch(
        do.call(add_author, c(list(study = s), a)),
        error = function(e) {
          debug_msg(e.message)
          return(s)
        }
      )
    }
    my_study(s)
  }, ignoreInit = TRUE)

  # . . aut_table ----
  output$aut_table <- renderDT({
    debug_msg("aut_table")

    aut_clear$depend()

    a <- authors()
    if (length(a) > 1) {
      shinyjs::show("aut_reorder")
    } else {
      shinyjs::hide("aut_reorder")
    }
    make_aut_list(a)
  },  escape = F,
      selection = "single",
      extensions = "RowReorder",
      rownames = FALSE,
      options = c(dt_options,
                  list(rowReorder = TRUE,
                       order = list(c(0 , 'asc'))
                      )
                  ),
      callback = JS(c(
        "table.on('row-reorder', function(e, details, changes) {",
        "  var op = JSON.stringify(details);",
        "  Shiny.onInputChange('aut_reorder', op);",
        "});"))
  )

  observeEvent(input$aut_reorder, {
    debug_msg("aut_reorder")

    info <- input$aut_reorder
    if (is.null(info) | class(info) != 'character') { return() }

    info <- jsonlite::fromJSON(txt=info)
    if (length(info) == 0) { return() }

    ord <- info[['oldPosition']] + 1
    a <- authors()
    authors(a[ord])
  })

  ## . . aut_edit ----
  observeEvent(input$aut_table_rows_selected, {
    debug_msg("aut_edit")
    idx <- input$aut_table_rows_selected

    a <- authors()[[idx]]
    updateTextInput(session, "aut_n", value = idx)
    updateTextInput(session, "given", value = a$given,
                    label = "Given Name(s) including initials" %>% i18n()$t())
    updateTextInput(session, "surname", value = a$surname,
                    label = "Last Name(s)" %>% i18n()$t())
    updateTextInput(session, "orcid",
                    value = ifelse(isFALSE(a$orcid), "", a$orcid),
                    label = "ORCiD" %>% i18n()$t())
    updateCheckboxGroupInput(session, "roles", selected = a$roles)
    updateActionButton(session, "aut_add", i18n()$t("Update Author"))

    # update custom author info
    a$given <- NULL
    a$surname <- NULL
    a$orcid <- NULL
    a$roles <- NULL
    nvdf(a) %>% aut_cinfo$info()

    if (length(a) > 0) shinyjs::runjs("openBox('aut_info-box');")

    shinyjs::removeClass("given", "warning")
    shinyjs::removeClass("surname", "warning")
    shinyjs::removeClass("orcid", "warning")
    shinyjs::show("aut_delete")
  }, ignoreNULL = TRUE)

  ## . . aut_delete ----
  observeEvent(input$aut_delete, {
    debug_msg("aut_delete")

    idx <- input$aut_table_rows_selected[1]
    if (length(idx) == 0) return()

    a <- authors()
    a[[idx]] <- NULL
    authors(a)

    shinyjs::click("aut_clear")
  }, ignoreNULL = TRUE)

  # . . aut_clear ----
  observeEvent(input$aut_clear, {
    debug_msg("aut_clear")

    updateActionButton(session, "aut_add", i18n()$t("Add Author"))
    updateTextInput(session, "aut_n", value = length(authors())+1)
    updateTextInput(session, "given", value = "",
                    label = "Given Name(s) including initials" %>% i18n()$t())
    updateTextInput(session, "surname", value = "",
                    label = "Last Name(s)" %>% i18n()$t())
    updateTextInput(session, "orcid", value = "",
                    label = "ORCiD" %>% i18n()$t())
    updateCheckboxGroupInput(session, "roles", selected = character(0))
    aut_cinfo$info(NULL)
    shinyjs::removeClass("given", "warning")
    shinyjs::removeClass("surname", "warning")
    shinyjs::removeClass("orcid", "warning")
    shinyjs::hide("aut_delete")

    aut_clear$trigger() # fix interface jitter
  }, ignoreNULL = TRUE)

  # . . credit_roles ----
  output$credit_roles <- renderUI({
    debug_msg("credit_roles")
    get_credit_roles()
  })

  # . . jats_text  ----
  output$jats_text <- renderText({
    debug_msg("jats_text")
    author_jats(my_study())
  })

  # . . download_jats ----
  output$download_jats <- downloadHandler(
    filename = function() {
      debug_msg("download_jats")
      paste0(input$study_name, "_credit.xml")
    },
    content = function(file) {
      j <- author_jats(my_study())
      write(j, file)
    }
  )

  # hypotheses ----
  debug_msg("---hypotheses---")

  # . . hyp_add ----
  observe({
    buttonable("hyp_add",
               input$hyp_id,
               input$hyp_desc)
  })

  observeEvent(input$hyp_add, {
    debug_msg("hyp_add")

    hyp <- list(
      study = my_study(),
      id = input$hyp_id,
      description = input$hyp_desc
    )
    hyp <- c(hyp, dfnv(hyp_cinfo$disp()))

    s <- tryCatch({
      do.call(add_hypothesis, hyp)
    },error = function(e) {
      shinyjs::alert(e$message)
      return(FALSE)
    })

    if (isFALSE(s)) return()

    # add criteria
    for (c in criteria()) {
      c$study <- s
      c$hypothesis_id <- input$hyp_id
      s <- do.call(add_criterion, c)
    }

    # add evaluations if they exist
    if (trimws(input$eval_cor_eval) != "") {
      s <- tryCatch({
        add_eval(s, "corroboration", input$eval_cor_eval,
                 input$eval_cor_desc, input$hyp_id)
        },
        message = function(e) {
          shinyjs::alert(e$message)
        },
        warning = function(e) {
          shinyjs::alert(e$message)
        },
        error = function(e) {
          shinyjs::alert(e$message)
          return(FALSE)
        }
      )
      if (isFALSE(s)) return(FALSE)
    }
    if (trimws(input$eval_fal_eval) != "") {
      s <- tryCatch({
        add_eval(s, "falsification", input$eval_fal_eval,
                 input$eval_fal_desc, input$hyp_id)
        },
        message = function(e) {
          shinyjs::alert(e$message)
        },
        warning = function(e) {
          shinyjs::alert(e$message)
        },
        error = function(e) {
          shinyjs::alert(e$message)
          return(FALSE)
        }
      )
      if (isFALSE(s)) return(FALSE)
    }

    my_study(s)

    # reset for new hypothesis
    shinyjs::click("hyp_clear")
  }, ignoreNULL = TRUE)

  # . . hyp_table ----
  output$hyp_table <- renderDT({
    debug_msg("hyp_table")

    hyp_clear$depend()
    h <- my_study()$hypotheses
    make_hyp_list(h)
  },  escape = 1:4,
      selection = "single",
      rownames = FALSE,
      options = dt_options
  )

  # . . hyp_clear ----
  observeEvent(input$hyp_clear, {
    debug_msg("hyp_clear")

    c("hyp_id", "hyp_desc", "crit_id", "crit_ana_id",
      "crit_result", "crit_operator", "crit_comparator",
      "eval_cor_eval", "eval_fal_eval") %>%
      lapply(shinyjs::reset)

    hyp_cinfo$info(NULL)

    shinyjs::hide("hyp_delete")
    updateActionButton(session, "hyp_add", i18n()$t("Add Hypothesis"))
    criteria(list())

    hyp_clear$trigger() # fix interface jitter
  })

  ## . . hyp_edit ----
  observeEvent(input$hyp_table_rows_selected, {
    debug_msg("hyp_edit")
    idx <- input$hyp_table_rows_selected
    if (length(idx) == 0) {
      shinyjs::click("hyp_clear")
      return()
    }
    shinyjs::show("hyp_delete")

    s <- my_study()
    h <- s$hypotheses[[idx]]

    # update criteria
    crit <- h$criteria
    names(crit) <- sapply(crit, `[[`, "id")
    criteria(crit)

    updateActionButton(session, "hyp_add", i18n()$t("Update Hypothesis"))
    updateTextInput(session, "hyp_id", value = h$id)
    updateTextAreaInput(session, "hyp_desc",
                        value = h$description)
    updateTextInput(session, "eval_cor_eval",
                    value = h$corroboration$evaluation)
    updateTextInput(session, "eval_fal_eval",
                    value = h$falsification$evaluation)
    updateTextAreaInput(session, "eval_cor_desc",
                    value = h$corroboration$description)
    updateTextAreaInput(session, "eval_fal_desc",
                    value = h$falsification$description)

    ## do something with h$conclusion ???

    # hyp custom info
    to_clear <- c("id", "description", "criteria",
                   "corroboration", "falsification",
                   "conclusion")
    h[to_clear] <- NULL
    nvdf(h) %>% hyp_cinfo$info()
    if (length(h) > 0) shinyjs::runjs("openBox('hyp_info-box');")
  })

  ## . . hyp_delete ----
  observeEvent(input$hyp_delete, {
    debug_msg("hyp_delete")

    idx <- input$hyp_table_rows_selected[1]
    if (length(idx) == 0) return()

    s <- my_study()
    s$hypotheses[[idx]] <- NULL
    my_study(s)
    shinyjs::click("hyp_clear")
  }, ignoreNULL = TRUE)

  # critera ----
  debug_msg("---criteria---")

  # . . crit_add ----
  observe({
    buttonable("crit_add",
               input$crit_id,
               input$crit_result,
               input$crit_comparator,
               input$crit_ana_id)
  })

  observeEvent(input$crit_add, {
    debug_msg("crit_add")
    crit <- criteria()

    # check and coerce comparator value
    bool_vals <- list("TRUE", "FALSE", "true", "false")
    comp <- input$crit_comparator # always a text value
    if (comp %in% bool_vals) {
      comp <- as.logical(comp)
    } else {
      num <- suppressWarnings(as.numeric(comp))
      if (!is.na(num)) comp <- num
    }

    crit[[input$crit_id]] <- list(
      id = input$crit_id,
      result = input$crit_result,
      operator = input$crit_operator,
      comparator = comp,
      analysis_id = input$crit_ana_id
    )

    criteria(crit)

    # reset criteria
    c("crit_id", "crit_result", "crit_comparator") %>%
      lapply(shinyjs::reset)
  }, ignoreNULL = TRUE)

  # . . crit_delete ----
  observeEvent(input$crit_delete, {
    debug_msg("crit_delete")

    idx <- input$crit_table_rows_selected[1]
    if (length(idx) == 0) return()

    crit <- criteria()
    crit[[idx]] <- NULL
    criteria(crit)
  }, ignoreNULL = TRUE)

  # . . crit_id ----
  observeEvent(input$crit_id, {
    debug_msg("crit_id")

    id <- input$crit_id
    newid <- id %>%
      gsub("^[^A-Za-z]", "", .) %>%
      gsub("[^[:alnum:]_\\.]", "", .)

    if (newid != id) {
      i18n()$t("Criterion IDs must start with a letter and only contain letters, numbers, underscores, and full stops.") %>%
        showNotification()
      updateTextInput(session, "crit_id", value = newid)
    }
  }, ignoreInit = TRUE)

  ## . . crit_edit ----
  observeEvent(input$crit_table_rows_selected, {
    debug_msg("crit_edit")
    crit <- criteria()
    cc <- crit[[input$crit_table_rows_selected]]
    updateTextInput(session, "crit_id", value = cc$id)
    updateSelectInput(session, "crit_ana_id", selected = cc$analysis_id)
    updateTextInput(session, "crit_result", value = cc$result)
    updateSelectInput(session, "crit_operator", selected = cc$operator)
    updateTextInput(session, "crit_comparator", value = cc$comparator)
  })

  # . . crit_table ----
  output$crit_table <- renderDT({
    debug_msg("crit_table")
    make_crit_list(criteria())
  },  escape = 1:5,
      selection = "single",
      rownames = FALSE,
      options = dt_options
  )

  # . . crit_warning ----
  output$crit_warning <- renderText({
    debug_msg("crit_warning")
    s <- my_study()
    if (length(s$analyses) > 0) {
      enable("crit_add")
      ""
    } else {
      disable("crit_add")
      i18n()$t("Add an analysis first to be able to add criteria.")
    }
  })

  # . . ana_return_list ----
  output$ana_return_list <- renderTable({
    debug_msg("ana_return_list")
    r <- return_list()
    data.frame(
      name = names(r),
      object = unlist(r)
    )
  })

  # . . add_return ----
  observeEvent(input$add_return, {
    debug_msg("add_return")

    r <- return_list()
    r[[input$ana_return_name]] <- input$ana_return_object
    return_list(r)
  }, ignoreNULL = TRUE)

  # analyses ----

  ## . . ana_add ----
  observe({
    # either return_list or ana_code need to be present
    r <- ifelse(return_list() %>% length == 0, "", "r")
    code <- ifelse(input$ana_lang == "constant", r, input$ana_code)
    buttonable("ana_add", input$ana_id, code)
  })
  observeEvent(input$ana_add, {
    debug_msg("ana_add")
    # add analysis
    ana <- list(
      study = my_study(),
      id = input$ana_id,
      type = "text"
    )

    if (input$ana_lang == "constant") {
      ana$return <- return_list()
    } else if (input$ana_lang == "R") {
      ana$code <- input$ana_code
    } else {
      ana$code <- "# see custom_code"
      ana$custom_code <- input$ana_code
    }
    ana <- c(ana, dfnv(ana_cinfo$disp()))

    s <- tryCatch({
      do.call(add_analysis, ana)
    },error = function(e) {
      shinyjs::alert(e$message)
      return(FALSE)
    })

    # reset inputs
    if (!isFALSE(s)) {
      my_study(s)
      shinyjs::show("study_analyse")
      shinyjs::click("ana_clear")
    }
  }, ignoreNULL = TRUE)

  ## . . ana_clear ----
  observeEvent(input$ana_clear, {
    debug_msg("ana_clear")

    c("ana_id", "ana_code", "ana_lang", "ana_return_name", "ana_return_object") %>%
      lapply(shinyjs::reset)

    ana_cinfo$info(NULL)

    shinyjs::hide("ana_delete")
    updateActionButton(session, "ana_add", i18n()$t("Add Analysis"))

    return_list(list())

    ana_clear$trigger() # fix interface jitter
  })

  # . . ana_lang ----
  observeEvent(input$ana_lang, {
    if (input$ana_lang == "constant") {
      shinyjs::runjs("openBox('ana_constant-box');")
      shinyjs::runjs("closeBox('ana_code-box');")
    } else {
      shinyjs::runjs("closeBox('ana_constant-box');")
      shinyjs::runjs("openBox('ana_code-box');")
    }
  }, ignoreNULL = TRUE)

  # . . ana_table ----
  output$ana_table <- renderDT({
    debug_msg("ana_table")
    ana_clear$depend()
    make_ana_list(my_study())
  },  escape = FALSE,
      selection = "single",
      rownames = FALSE,
      options = dt_options
  )

  ## . . ana_edit ----
  observeEvent(input$ana_table_rows_selected, {
    debug_msg("ana_edit")
    idx <- input$ana_table_rows_selected
    if (length(idx) == 0) {
      shinyjs::click("ana_clear")
      return()
    }
    shinyjs::show("ana_delete")

    s <- my_study()
    a <- s$analyses[[idx]]

    updateTextInput(session, "ana_id", value = a$id)
    if (is.null(a$custom_code)) {
      code <- paste(a$code, collapse = "\n")
      updateSelectInput(session, "ana_lang", selected = "R")
    } else {
      code <- paste(a$custom_code, collapse = "\n")
      updateSelectInput(session, "ana_lang", selected = "other")
    }
    updateTextAreaInput(session, "ana_code", value = code)
    updateActionButton(session, "ana_add", i18n()$t("Update Analysis"))

    if (length(a$results) > 0) shinyjs::runjs("openBox('ana_results-box');")

    # ana custom info
    to_clear <- c("id", "code", "func", "results", "custom_code")
    a[to_clear] <- NULL
    nvdf(a) %>% ana_cinfo$info()
    if (length(a) > 0) shinyjs::runjs("openBox('ana_info-box');")
  })

  ## . . ana_results ----
  output$ana_results <- renderUI({
    debug_msg("ana_results")
    if (is_nowt(input$ana_id)) return()

    s <- isolate(my_study())
    a_ids <- sapply(s$analyses, `[[`, "id")
    idx <- match(input$ana_id, a_ids)

    s$analyses[[idx]]$results %>%
      nested_list() %>%
      markdown::renderMarkdown(text = .) %>%
      HTML()
  })

  ## . . ana_delete ----
  observeEvent(input$ana_delete, {
    debug_msg("ana_delete")
    idx <- input$ana_table_rows_selected[1]
    if (length(idx) == 0) return()

    s <- my_study()
    s$analyses[[idx]] <- NULL
    if (length(s$analyses) == 0) {
      shinyjs::hide("study_analyse")
    }
    my_study(s)
    shinyjs::click("ana_clear")
  }, ignoreNULL = TRUE)

  # data ----
  debug_msg("---data---")

  ## . . dat_add ----
  observe({
    buttonable("dat_add",
               input$dat_id)
  })
  observeEvent(input$dat_add, {
    debug_msg("dat_add")
    data <- loaded_data()
    nm <- trimws(input$dat_id)

    dat <- list(
      study = my_study(),
      id = nm,
      description = input$dat_desc
    )

    # add data and design
    if (ncol(data) > 0 & nrow(data) > 0) {
      dat$data <- data
      des <- attr(data, "design")
      if (!is.null(des)) dat$design <- des
    }

    # add custom info
    dat <- c(dat, dfnv(dat_cinfo$disp()))

    s <- tryCatch({
      do.call(add_data, dat)
    },error = function(e) {
      shinyjs::alert(e$message)
      return(FALSE)
    })

    if (isFALSE(s)) return()

    ## add codebook
    idx <- match(nm, sapply(s$data, "[[", "id"))[1]
    if (!is.na(idx)) s$data[[idx]]$codebook <- cb()

    my_study(s)

    ## reset add data interface
    shinyjs::click("dat_clear")
  }, ignoreNULL = TRUE)

  # . . dat_file ----
  observeEvent(input$dat_file, {
    debug_msg("dat_file")
    req(input$dat_file)

    if (input$dat_id == "") {
      input$dat_file$datapath %>%
        tools::file_ext() %>%
        paste0("." , .) %>%
        gsub("", input$dat_file$name) %>%
        updateTextInput(session, "dat_id", value = .)
    }

    d <- rio::import(input$dat_file$datapath)
    loaded_data(d)
    cb(codebook(d, name = input$dat_id, return = "list"))
  })

  # . . update cb name ----
  observe({
    cb <- cb()
    if (length(cb)) {
      cb$name <- input$dat_id
      cb(cb)
    }
  })

  # . . data_table ----
  output$data_table <- renderDT({
    debug_msg("data_table")
    loaded_data()
  }, rownames = FALSE,
     selection = "none")

  # . . dat_table ----
  output$dat_table <- renderDT({
    debug_msg("dat_table")
    dat_clear$depend()
    d <- my_study()$data
    make_dat_list(d)
  },  selection = 'single',
      rownames = FALSE,
      options = dt_options
  )

  # . . dat_edit ----
  observeEvent(input$dat_table_rows_selected, {
    debug_msg("dat_edit")
    idx <- input$dat_table_rows_selected
    if (length(idx) == 0) {
      shinyjs::click("dat_clear")
      return()
    }

    s <- my_study()
    d <- s$data[[idx]]
    desc <- if_nowt(d$description)

    updateTextInput(session, "dat_id", value = d$id)
    updateTextAreaInput(session, "dat_desc", value = desc)

    # data and codebook
    if (is.null(d$data)) d$data <- data.frame()
    loaded_data(d$data)
    if (nrow(loaded_data()) > 0) shinyjs::runjs("openBox('data-box');")
    cb(get_codebook(s, data_id = idx))

    # dat custom info
    to_clear <- c("@context", "@type", "name", "schemaVersion", "variableMeasured")
    d$codebook[to_clear] <- NULL
    nvdf(d$codebook) %>% dat_cinfo$info()
    if (length(d$codebook) > 0) shinyjs::runjs("openBox('dat_info-box');")

    updateActionButton(session, "dat_add", i18n()$t("Update Data"))
    shinyjs::show("dat_delete")
  }, ignoreNULL = TRUE)

  # . . codebook_json ----
  output$codebook_json <- renderText({
    debug_msg("codebook_json")
    cb()  %>%
      jsonlite::toJSON(auto_unbox = TRUE) %>%
      jsonlite::prettify(4)
  })

  ## . . dat_delete ----
  observeEvent(input$dat_delete, {
    debug_msg("dat_delete")
    idx <- input$dat_table_rows_selected[1]
    if (length(idx) == 0) return()

    s <- my_study()
    s$data[[idx]] <- NULL
    my_study(s)
    shinyjs::click("dat_clear")
  }, ignoreNULL = TRUE)

  # . . dat_clear ----
  observeEvent(input$dat_clear, {
    debug_msg("dat_clear")

    shinyjs::hide("dat_delete")
    updateActionButton(session, "dat_add", i18n()$t("Add Data"))
    loaded_data(data.frame())
    cb(codebook(loaded_data(), "", return = "list"))

    c("dat_id", "dat_desc", "dat_file", "var_name", "var_desc", "var_type") %>%
      lapply(shinyjs::reset)

    dat_cinfo$info(NULL)

    dat_clear$trigger() # fix interface jitter
  }, ignoreNULL = TRUE)

  # . . cb() ----
  reactive({
    debug_msg("cb")
    cb <- tryCatch({
      get_codebook(my_study(), input$dat_id)
    }, error = function(e) {
      message("caught cb():\n", e)
      return(codebook(loaded_data(),
                      input$dat_id,
                      return = "list"))
    })

    cb(cb)
  })

  # . . var_list ----
  output$var_list <- renderUI({
    debug_msg("var_list")
    varnames <- names(loaded_data())
    if (length(varnames)==0) return("")

    paste0("<button>", varnames, "</button>") %>%
      paste(collapse = "\n    ") %>%
      HTML()
  })

  # . . var_selected ----
  observeEvent(input$var_selected, {
    debug_msg("var_selected")
    v <- tryCatch({
        vm <- cb()$variableMeasured
        names(vm) <- sapply(vm, "[[", "name")
        vm[[input$var_selected]]
      },
      error = function(e) {
        message("caught var_selected v:\n", e)
        return(list(name = "",
                    description = "",
                    dataType = "string"))
      }
    )

    updateTextInput(session, "var_name",
                    value = v$name)
    updateTextInput(session, "var_desc",
                    value = v$description)
    updateSelectInput(session, "var_type",
                      selected = v$dataType)
  })

  # . . var_update ----
  observeEvent(input$var_update, {
    debug_msg("var_update")

    cb <- cb()
    vm <- cb$variableMeasured

    if (length(vm)) {
      nm <- sapply(vm, "[[", "name")
      idx <- match(input$var_name, nm)
      vm[[idx]]["description"] <- input$var_desc
      vm[[idx]]["dataType"] <- input$var_type
      cb$variableMeasured <- vm
      cb(cb)
    }
  })

  # . . loaded_data ----
  observeEvent(loaded_data(), {
    if (nrow(loaded_data()) == 0) {
      shinyjs::hide("download_data")
      shinyjs::hide("download_cb")
    } else {
      shinyjs::show("download_data")
      shinyjs::show("download_cb")
    }
  })

  # . . download_data ----
  output$download_data <- downloadHandler(
    filename = function() {
      debug_msg("download_data")
      paste0("data_", input$dat_id, ".csv")
    },
    content = function(file) {
      readr::write_csv(loaded_data(), file)
    }
  )

  # . . download_cb ----
  output$download_cb <- downloadHandler(
    filename = function() {
      debug_msg("download_cb")
      paste0("data_", input$dat_id, ".json")
    },
    content = function(file) {
      cb() %>%
        jsonlite::toJSON(auto_unbox = TRUE) %>%
        jsonlite::prettify(4) %>%
        write(file)
    }
  )

  # simulation ----
  debug_msg("---simulation---")

  #  . . sim_data ----
  observeEvent(input$sim_data, {
    debug_msg("sim_data")

    d <- tryCatch(faux::sim_design(
      design = design(),
      empirical = (input$empirical == "TRUE"),
      long = (input$long == "TRUE"),
      plot = FALSE
    ), error = function(e) {
      message(e$message)
      return(FALSE)
    })

    if (isFALSE(d)) return()

    loaded_data(d)
    if (nrow(d) > 0) shinyjs::runjs("openBox('data-box');")

    cb <- tryCatch({
      codebook(d, vardesc = sim$vardesc, return = "list")
    }, error = function(e) {
      return(list())
    })
    cb(cb)

  }, ignoreNULL = TRUE)

  ## . . sim_clear ----
  observeEvent(input$sim_clear, {
    debug_msg("sim_clear")

    c("dv_name", "dv_def", "id_name", "id_def",
    "n", "mu", "sd", "r",
    "factor_name", "factor_desc", "factor_levels") %>%
      lapply(shinyjs::reset)

    level_list(list(A1 = "", A2 = ""))

    loaded_data(data.frame())
    sim$within <- list()
    sim$between = list()
    sim$vardesc = list(description = list())
  }, ignoreNULL = TRUE)

  ## . . sim_demo ----
  observeEvent(input$sim_demo, {
    debug_msg("sim_demo")

    loaded_data(data.frame())
    updateTextInput(session, "n", value = "50, 30")
    updateTextInput(session, "mu", value = "10, 15, 15, 20")
    updateTextInput(session, "sd", value = "5")
    updateTextInput(session, "r", value = "0.5")
    updateTextInput(session, "dv_name", value = "score")
    updateTextInput(session, "dv_def", value = "Test Score")
    updateTextInput(session, "id_name", value = "id")
    updateTextInput(session, "id_def", value = "Pet ID")

    sim$between <- list(pet = c(cat = "Kitty!", dog = "Woof!"))
    sim$within  <- list(time = c(am = "morning", pm = "night"))
    sim$vardesc <- list(description = list(pet = "Type of Pet",
                                           time = "Time of Day"))
  }, ignoreNULL = TRUE)

  # . . b_cells ----
  observe({
    debug_msg("b_cells")
    sim$b_cells <- faux:::cell_combos(sim$between, input$dv_name)
  })

  # . . w_cells ----
  observe({
    debug_msg("w_cells")
    sim$w_cells <- faux:::cell_combos(sim$within, input$dv_name)
    if (length(sim$w_cells) > 1) {
      shinyjs::show("r")
    } else {
      shinyjs::hide("r")
    }
  })

  # . . cell_names ----
  observe({
    debug_msg("cell_names")
    # calculate cell combo names
    lb <- length(sim$b_cells)
    lw <- length(sim$w_cells)
    lr <- lw*(lw-1)/2

    if (lb == 1) {
      sim$cell_names <- sim$w_cells
    } else if (lw == 1) {
      sim$cell_names <- sim$b_cells
    } else {
      sim$cell_names <- list(sim$b_cells, sim$w_cells) %>%
        rev() %>%
        do.call(expand.grid, .) %>%
        dplyr::mutate(nm = paste0(Var1, "_", Var2)) %>%
        dplyr::pull(nm)
    }

    ## n
    lab <- paste0("n (", lb, ")")
    updateTextInput(session, "n", lab)

    ## mu
    lab <- paste0("mu (", lb*lw, ")")
    updateTextInput(session, "mu", lab)

    ## sd
    lab <- paste0("sd (", lb*lw, ")")
    updateTextInput(session, "sd", lab)

    ## r
    if (lb == 1) {
      lab <- paste0("r (", lr, ")")
    } else {
      lab <- paste0("r (", lr, " or ", lr*lb, ")")
    }
    updateTextInput(session, "r", lab)
  })

  # . . n ----
  observeEvent(c(input$n, sim$b_cells), {
    debug_msg("n")

    spl <- strsplit(input$n, "(,|;| )")[[1]] %>%
      `[`(., grep(".+", .)) # get rid of blanks
    comp <- as.integer(spl)
    if (length(comp) == 0) {
      shinyjs::addClass("n", "warning")
      return()
    }

    if (isTRUE(all(comp == spl))) {
      sim$n <- comp
      lb <- length(sim$b_cells)
      if (length(sim$n) == 1) sim$n <- rep(sim$n, lb)
      if (lb == length(sim$n)) {
        shinyjs::removeClass("n", "warning")
      } else {
        shinyjs::addClass("n", "warning")
        # trim or extend to length = lb
        sim$n <- sim$n[1:lb]
        if (length(is.na(sim$n)) > 0 ) {
          # replace NAs with existing values
          suppressWarnings(
            sim$n[is.na(sim$n)] <- sim$n[!is.na(sim$n)]
          )
        }
      }
      names(sim$n) <- sim$b_cells
      if (length(sim$n) == 1) names(sim$n) <- NULL
    } else {
      "All inputs for n must be integers" %>%
        i18n()$t() %>%
        shinyjs::alert()
      shinyjs::addClass("n", "warning")
    }
  }, ignoreInit = TRUE)

  # . . mu ----
  observeEvent(c(input$mu, sim$cell_names), {
    debug_msg("mu")

    spl <- strsplit(input$mu, "(,|;| )")[[1]] %>%
      `[`(., grep(".+", .)) %>% # get rid of blanks
      `[`(., grep("[^-|\\.]$", .)) # remove "-", ".", "-."
    comp <- as.numeric(spl)
    if (length(comp) == 0) {
      shinyjs::addClass("mu", "warning")
      return()
    }

    if (isTRUE(all(!is.na(comp)))) {
      sim$mu <- comp
      lc <- length(sim$cell_names)
      if (length(sim$mu) == 1) sim$mu <- rep(sim$mu, lc)
      if (lc == length(sim$mu)) {
        shinyjs::removeClass("mu", "warning")
      } else {
        shinyjs::addClass("mu", "warning")
        # trim or extend to length = lc
        sim$mu <- sim$mu[1:lc]
        if (length(is.na(sim$mu)) > 0 ) {
          # replace NAs with existing values
          suppressWarnings(
            sim$mu[is.na(sim$mu)] <- sim$mu[!is.na(sim$mu)]
          )
        }
      }
      names(sim$mu) <- sim$cell_names
      if (length(sim$mu) == 1) names(sim$mu) <- NULL
    } else {
      "All inputs for mu must be numbers" %>%
        i18n()$t() %>%
        shinyjs::alert()
      shinyjs::addClass("mu", "warning")
    }
  }, ignoreInit = TRUE)

  # . . sd ----
  observeEvent(c(input$sd, sim$cell_names), {
    debug_msg("sd")

    spl <- strsplit(input$sd, "(,|;| )")[[1]] %>%
      `[`(., grep("-?\\.?.+", .)) %>% # get rid of blanks
      `[`(., grep("[^\\.]$", .)) # remove "."
    comp <- as.numeric(spl)
    if (length(comp) == 0) {
      shinyjs::addClass("sd", "warning")
      return()
    }

    if (isTRUE(all(!is.na(comp))) &
        isTRUE(all(comp > 0))) {
      sim$sd <- comp
      lc <- length(sim$cell_names)
      if (length(sim$sd) == 1) sim$sd <- rep(sim$sd, lc)
      if (lc == length(sim$sd)) {
        shinyjs::removeClass("sd", "warning")
      } else {
        shinyjs::addClass("sd", "warning")
        # trim or extend to length = lc
        sim$sd <- sim$sd[1:lc]
        if (length(is.na(sim$sd)) > 0 ) {
          # replace NAs with existing values
          suppressWarnings(
            sim$sd[is.na(sim$sd)] <- sim$sd[!is.na(sim$sd)]
          )
        }
      }
      names(sim$sd) <- sim$cell_names
      if (length(sim$sd) == 1) names(sim$sd) <- NULL
    } else {
      "All inputs for sd must be positive numbers" %>%
        i18n()$t() %>%
        shinyjs::alert()
      shinyjs::addClass("sd", "warning")
    }
  }, ignoreInit = TRUE)

  # . . r ----
  observeEvent(c(input$r, sim$w_cells, sim$b_cells), {
    debug_msg("r")

    # return if no within factors
    if (length(sim$w_cells) < 2) return()

    spl <- strsplit(input$r, "(,|;| )")[[1]] %>%
      `[`(., grep(".+", .)) %>% # get rid of blanks
      `[`(., grep("[^-|\\.]$", .)) # remove "-", ".", "-."
    comp <- as.numeric(spl)
    if (length(comp) == 0) {
      shinyjs::addClass("r", "warning")
      return()
    }

    # how many for upper right triangle
    r_pairs <- faux:::unique_pairs(sim$w_cells)
    lb <- length(sim$b_cells)
    lr <- length(r_pairs)

    if (isTRUE(all(!is.na(comp))) &
        isTRUE(all(abs(comp) <= 1))) {
      shinyjs::removeClass("r", "warning")

      # only 1 number, repeat lr times
      if (length(comp) == 1) comp <- rep(comp, lr)

      # <lr numbers, extend to length = lr
      if (length(comp) < lr) {
        shinyjs::addClass("r", "warning")
        comp <- comp[1:lr]
        comp[is.na(comp)] <- 0
      }

      # lr numbers, repeat for each between cell
      if (length(comp) == lr) {
        comp <- rep(comp, lb)
      }

      # !lr*lb numbers, trim or extend to length = lr*lb
      if (length(comp) != lr*lb) {
        shinyjs::addClass("r", "warning")
        comp <- comp[1:(lr*lb)]
        if (length(is.na(comp)) > 0) {
          comp[is.na(comp)] <- 0
        }
      }

      # set sim$r from comp (now lr*lb-length vector)
      sim$r <- matrix(comp, nrow = lr) %>%
        as.data.frame() %>%
        as.list() %>%
        lapply(function(x) { names(x) <- r_pairs; x })
      names(sim$r) <- sim$b_cells
    } else {
      "All inputs for r must be numbers between -1 and 1" %>%
        i18n()$t() %>%
        shinyjs::alert()
      shinyjs::addClass("r", "warning")
    }
  }, ignoreInit = TRUE)

  # . . level_list ----
  observeEvent(level_list(), {
    debug_msg("level_list")
    # always update disp when original updates
    level_list() %>% level_list_disp()
  }, ignoreInit = TRUE)

  # . . factor_levels ----
  observeEvent(input$factor_levels, {
    debug_msg("factor_levels")

    ll <- level_list_disp()

    if (length(ll) < input$factor_levels) {
      start <- length(ll) + 1
      end <- input$factor_levels
      for (i in start:end) {
        if (input$factor_name == "") {
          ll[i] <- ""
        } else {
          nm <- paste0(input$factor_name, i)
          ll[nm] <- paste(input$factor_name, i, "Description")
        }
      }
    }
    # truncate if needed
    ll <- ll[1:input$factor_levels]
    level_list(ll)
  }, ignoreInit = TRUE)

  # . . factor_name ----
  observeEvent(input$factor_name, {
    debug_msg("factor_name")

    if (input$factor_name == "") {
      shinyjs::hide("level_list_display")
    } else {
      # change default-looking names
      ll <- level_list_disp()

      prefixes <- gsub("\\_?\\d+$", "", names(ll))

      if (unique(prefixes) %>% length() == 1) {
        n <- length(ll)
        ll <- rep("", n)
        names(ll) <- paste0(input$factor_name, 1:n)
        level_list(ll)
      }

      show("level_list_display")
    }
  })

  # . . level_list_display ----
  output$level_list_display <- renderUI({
    debug_msg("level_list_display")

    ll <- level_list() # only trigger when ll changes

    x <- lapply(1:length(ll), function(i) {
      nm <- paste0("level_name_", i)
      dc <- paste0("level_desc_", i)
      fluidRow(column(3, paste("Level", i)),
               column(3, textInput(nm, NULL, names(ll)[[i]])),
               column(6, textInput(dc, NULL, ll[[i]],
                                   placeholder = "Description")))
    })
    x$width = 12

    do.call(box, x)
  })

  # . . level_list_update ----
  # changed via www/custom.js
  observeEvent(input$level_list_update, {
    debug_msg("level_list_update")

    nm <- names(get0("input"))
    lnames <- grep("^level_name_\\d+", nm) %>% `[`(nm, .) %>% sort()
    ldescs <- grep("^level_desc_\\d+", nm) %>% `[`(nm, .)%>% sort()

    ll <- lapply(ldescs, function(x) input[[x]])
    ln <- lapply(lnames, function(x) input[[x]])
    names(ll) <- ln

    # warn about duplicates
    mapply(function(id, dupe) {
      if (dupe) {
        shinyjs::addClass(id, "warning")
      } else {
        shinyjs::removeClass(id, "warning")
      }
    }, lnames, duplicated(ln))

    level_list_disp(ll) # only update disp
  }, ignoreNULL = TRUE)

  # . . factor_add ----
  observe({
    buttonable("factor_add",
               input$factor_name)
  })
  observeEvent(input$factor_add, {
    debug_msg("factor_add")

    if (input$factor_chooser != "New Factor") {
      # get rid of the old one
      sim$within[[input$factor_chooser]] <- NULL
      sim$between[[input$factor_chooser]] <- NULL
    }

    # update from displayed, copy names to blank desc
    ll <- level_list_disp()
    blanks <- grep("^\\s*$", ll)
    ll[blanks] <- names(ll)[blanks]
    sim[[input$factor_type]][[input$factor_name]] <- ll
    sim$vardesc$description[[input$factor_name]] <-
      if_nowt(input$factor_desc, input$factor_name)

    # reset inputs
    nm <- names(get0("input"))
    lnames <- grep("^level_name_\\d+", nm) %>% `[`(nm, .)
    ldescs <- grep("^level_desc_\\d+", nm) %>% `[`(nm, .)
    c(ldescs, lnames) %>%
      lapply(function(id) updateTextInput(session, id, value = ""))

    c("factor_name", "factor_desc", "factor_levels") %>%
      lapply(shinyjs::reset)
    list(A1 = "",
         A2 = "") %>% level_list()


    updateActionButton(session, "factor_add", i18n()$t("Add Factor"))
    updateSelectInput(session, "factor_chooser", selected = "New Factor")
  }, ignoreNULL = TRUE)

  ## . . factor_chooser ----
  observeEvent(input$factor_chooser, {
    w <- names(design()$within)
    b <- names(design()$between)
    x <- input$factor_chooser
    if (x %in% w ) {
      to_edit <- design()$within[[x]]
      updateSelectInput(session, "factor_type",
                        selected = "within")
    } else if (x %in% b) {
      to_edit <- design()$between[[x]]
      updateSelectInput(session, "factor_type",
                        selected = "between")
    } else {
      updateActionButton(session, "factor_add", i18n()$t("Add Factor"))
      return()
    }

    updateTextInput(session, "factor_name", value = x)
    updateTextInput(session, "factor_desc",
                    value = sim$vardesc$description[[x]])
    updateSelectInput(session, "factor_levels",
                      selected = length(to_edit))
    level_list(to_edit)
    updateActionButton(session, "factor_add", i18n()$t("Update Factor"))
  }, ignoreNULL = TRUE)

  ## . . sim_plot ----
  output$sim_plot <- renderPlot({
    debug_msg("sim_plot")

    g <- tryCatch({
      plot(design(), geoms = input$plot_geoms)
    }, error = function(e) {
      message(e$message)
      return(ggplot2::ggplot())
    })

    g + ggplot2::theme(text = ggplot2::element_text(size = 16))
  })

  ## . . design ----
  observe({
    debug_msg("design")

    dv_name <- if_nowt(input$dv_name, "y")
    dv <- if_nowt(input$dv_def, dv_name)
    names(dv) <- dv_name

    id_name <- if_nowt(input$id_name, "id")
    id <- if_nowt(input$id_def, id_name)
    names(id) <- id_name

    des <- tryCatch(faux::check_design(
      within = sim$within,
      between = sim$between,
      n = sim$n,
      mu = sim$mu,
      sd = sim$sd,
      r = sim$r,
      dv = dv,
      id = id,
      vardesc = sim$vardesc,
      plot = FALSE
    ),
    error = function(e) {
      message(e$message)
      return(FALSE)
    })

    if (!isFALSE(des)) design(des)
  }, priority = -1)

  # . . design_summary ----
  output$design_summary <- renderDT({
    debug_msg("design_summary")

    w <- names(design()$within)
    b <- names(design()$between)
    updateSelectInput(session, "factor_chooser", choices = c("New Factor", w, b))

    design_summary(design())
  },
     selection = 'multiple',
     rownames = FALSE,
     options = dt_options
  )



  # methods ----
  debug_msg("---methods---")

  # . . met_file ----
  observeEvent(input$met_file, {
    debug_msg("met_file")

    path <- input$met_file$datapath
    ext <- tools::file_ext(path) %>% tolower()

    txt <- tryCatch({
      readLines(path) %>% paste(collapse = "\n")
    }, error = function(e) {
      shinyjs::alert(e$message)
      return("")
    })

    updateTextAreaInput(session, "met_text", value = "")
    if (ext == "json") {
      updateRadioButtons(session, "met_type", selected = "json")
    } else if (ext == "yml") {
      updateRadioButtons(session, "met_type", selected = "yml")
    }
    updateTextAreaInput(session, "met_text", value = txt)
  }, ignoreNULL = TRUE)

  # . . met_type ----
  observeEvent(input$met_type, {
    debug_msg("met_type")

    if (trimws(input$met_text) == "") return()

    if (input$met_type == "yaml") {
      # message("try to convert from JSON to YAML")
      tryCatch({
        m <- jsonlite::fromJSON(input$met_text, TRUE)
        y <- yaml::as.yaml(m)
        updateTextAreaInput(session, "met_text", value = y)
      })
    } else if (input$met_type == "json") {
      # message("try to convert from YAML to JSON")
      tryCatch({
        m <- yaml::yaml.load(input$met_text)
        j <- jsonlite::toJSON(m, auto_unbox = TRUE) %>%
          jsonlite::prettify(4) %>%
          paste(collapse = "\n")
        updateTextAreaInput(session, "met_text", value = j)
      })
    }
  }, ignoreInit = TRUE)

  # . . met_text ----
  observeEvent(input$met_text, {
    debug_msg("met_text")

    if (input$met_text == "") { return() }

    tryCatch({
      if (input$met_type == "json") {
        err <- jsonlite::validate(input$met_text) %>%
          attr("err")
        if (!is.null(err)) stop(err, "")

        m <- jsonlite::fromJSON(input$met_text, TRUE)
        v <- "valid JSON"
      } else if (input$met_type == "yaml") {
        m <- yaml::yaml.load(input$met_text)
        v <- "valid YAML"
      } else {
        m <- strsplit(input$met_text, "\n")[[1]]
        v <- ""
      }
      shinyjs::removeClass('met_text', 'warning')
      output$met_err <- renderText(v)

      # update methods
      s <- my_study()
      s$methods[[1]] <- m
      my_study(s)
    }, error = function(e) {
      output$met_err <- renderText(e$message)
      shinyjs::addClass('met_text', 'warning')
    })
  }, ignoreInit = TRUE)

  # . . met_prettify ----
  observeEvent(input$met_prettify, {
    debug_msg("met_prettify")
    if (input$met_type == "json") {
      tryCatch({
        txt <- input$met_text %>%
          jsonlite::fromJSON(TRUE) %>%
          jsonlite::toJSON(auto_unbox = TRUE) %>%
          jsonlite::prettify(4) %>%
          paste(collapse = "\n")

        updateTextAreaInput(session, "met_text", value = txt)
      }, error = function(e) {})
    }
  }, ignoreNULL = TRUE)

  # . . met_drop_empty ----
  observeEvent(input$met_drop_empty, {
    s <- my_study()
    m <- s$methods[[1]] %>%
      drop_empty()
    my_study(s)

    if (input$met_type == "yaml") {
      txt <- yaml::as.yaml(m)
    } else if (input$met_type == "json") {
      txt <- m %>%
        jsonlite::toJSON(auto_unbox = TRUE) %>%
        jsonlite::prettify(4) %>%
        paste(collapse = "\n")
    } else {
      txt <- unlist(m) %>%
        paste(collapse = "\n")
    }

    updateTextAreaInput(session, "met_text", value = txt)
  }, ignoreNULL = TRUE)

  # summary ----
  debug_msg("---summary---")

  # . . json_text  ----
  output$json_text <- renderText({
    debug_msg("json_text")
    my_study() %>%
      study_to_json(data_values = input$dat_include)
  })

  # . . download_json ----
  output$download_json <- downloadHandler(
    filename = function() {
      debug_msg("download_json")
      paste0(input$study_name, ".json")
    },
    content = function(file) {
      j <- my_study() %>%
        study_to_json(data_values = input$dat_include)
      write(j, file)
    }
  )

  # . . script_text  ----
  output$script_text <- renderText({
    debug_msg("script_text")
    tryCatch({
      make_script(
        study = my_study(),
        data_path = if (input$dat_embed) NULL else "data",
        data_format = "csv",
        use_rmarkdown = (input$script_ext == ".Rmd"),
        header_lvl = input$script_header_lvl
      )
    }, error = function(e) {
      return(e)
    })
  })

  # . . download_script ----
  output$download_script <- downloadHandler(
    filename = function() {
      debug_msg("download_script")
      sname <- gsub("[^A-Za-z0-9]", "_", input$study_name)
      ext <- ifelse(input$dat_embed, input$script_ext, ".zip")
      paste0(sname, "_script", ext)
    },
    content = function(file) {
      # set up paths
      sname <- gsub("[^A-Za-z0-9]+", "_", input$study_name)
      dir_path <- file.path(tempdir(), sname)

      if (dir.exists(dir_path)) unlink(dir_path, TRUE)
      dir.create(dir_path)
      #on.exit(unlink(dir_path, TRUE))

      tryCatch({
        if (input$dat_embed) {
          make_script(
            study = my_study(),
            path = file,
            data_path = NULL,
            data_format = "csv",
            use_rmarkdown = (input$script_ext == ".Rmd"),
            header_lvl = input$script_header_lvl
          )
        } else {
          # change wd to tempdir for zipping
          my_wd<-getwd()
          on.exit(setwd(my_wd))
          setwd(dir_path)

          make_script(
            study = my_study(),
            path = "_script",
            data_path = "data",
            data_format = "csv",
            use_rmarkdown = (input$script_ext == ".Rmd"),
            header_lvl = input$script_header_lvl
          )

          setwd(tempdir())
          utils::zip(file, sname)
        }
      }, error = function(e) {
        shinyjs::alert(e)
      })
    }
  )

  # . . download_pre ----
  output$download_pre <- downloadHandler(
    filename = function() {
      debug_msg("download_pre")
      paste0(input$study_name, "_prereg.html")
    },
    content = function(file) {
      study_save(my_study(), file, format = "prereg")
    }
  )

  # . . download_post ----
  output$download_post <- downloadHandler(
    filename = function() {
      debug_msg("download_post")
      paste0(input$study_name, "_postreg.html")
    },
    content = function(file) {
      study_save(my_study(), file, format = "postreg")
    }
  )

  ## . . human_readable ----
  observeEvent(my_study(), {
    debug_msg("human_readable")

    s <- my_study()
    lvl <- 3
    capture.output({
      i <- output_info(s, lvl, "html")
      h <- output_hypotheses(s, lvl, "html")
      d <- output_data(s, lvl, "html")
      a <- output_analyses(s, lvl, "html")
      r <- output_results(s, lvl, "html")
    })

    ia <- strsplit(i, "<h4.*>Authors</h4>")[[1]]

    output$out_study <- renderUI(HTML(ia[1]))
    output$out_aut <- renderUI(HTML(ia[2]))
    output$out_hyp <- renderUI(HTML(h))
    output$out_ana <- renderUI(HTML(a))
    output$out_dat <- renderUI(HTML(d))
    output$out_res <- renderUI(HTML(r))
  })


  # inputs ----
  # . . load_json ----
  observeEvent(input$load_json, {
    debug_msg("load_json")

    tryCatch({
      s <- study(input$load_json$datapath)
      update_from_study(s)
    }, error = function(e) {
      shinyjs::alert(e$message)
    })
  }, ignoreNULL = TRUE)

  # . . update_from_study ----
  update_from_study <- function(study) {
    debug_msg("update_from_study")

    my_study(study)

    a <- lapply(study$author, function(x) {
      x$surname <- x$name$surname
      x$given <- x$name$given
      x$name <- NULL
      x
    })
    authors(a)
    updateTextInput(session, "aut_n", value = length(a)+1)

    updateTextInput(session, "study_name",
                    value = study$name)
    updateTextInput(session, "study_title",
                    value = study$info$title)
    updateTextAreaInput(session, "study_desc",
                        value = study$info$description)
    updateTextInput(session, "study_keywords",
                    value = paste(study$info$keywords, sep = "; "))

    # study custom info
    si <- study$info
    si$description <- NULL
    si$title <- NULL
    si$keywords <- NULL
    nvdf(si) %>% study_cinfo$info()
    if (length(si) > 0) shinyjs::runjs("openBox('study_info-box');")

    # update crit dropdown
    a <- sapply(study$analyses, "[[", "id")
    updateSelectInput(session, "crit_ana_id", choices = a)
    if (length(study$analyses) > 0) {
      shinyjs::show("study_analyse")
    }
  }

  # . . demo ----
  observeEvent(input$demo, {
    debug_msg("demo")
    s <- scienceverse::study_demo
    update_from_study(s)
  })

  # pre ----
  # . . pre_sections ----
  observeEvent(my_study(), {
    debug_msg("pre_sections")
    s <- my_study()

    # TODO: make more fine grained
    sec <- names(s)
    hyp <- sapply(s$hypotheses, `[[`, "id")
    aut <- lapply(s$authors, `[[`, "name") %>%
      sapply(paste, collapse = " ")
    dat <- sapply(s$data, `[[`, "id")
    met <- sapply(s$methods, `[[`, "id")
    ana <- sapply(s$analyses, `[[`, "id")
    ch <- list("Hypotheses" = c("All hypotheses" = "hypotheses", hyp),
                "Authors" = c("All authors" = "authors", aut),
                "Data" = c("All data" = "data", dat),
                "Methods" = c("All methods" = "methods", met),
                "Analyses" = c("All analyses" = "analyses", ana)
    )

    updateSelectInput(session, "pre_sections", choices = ch)
  })


  # save_trans ----
  save_trans(trans_text, trans_labels)

  debug_msg("server functions created")

  if (!is.null(.app.study.)) {
    update_from_study( .app.study. )
  }

} # end server()

shinyApp(ui, server)
